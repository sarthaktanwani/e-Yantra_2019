
Color Sensor Demo Code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  0000033a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000002c6  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000008  00800200  00800200  0000033a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000033a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000036c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000090  00000000  00000000  000003ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000f67  00000000  00000000  0000043c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c81  00000000  00000000  000013a3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000610  00000000  00000000  00002024  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000118  00000000  00000000  00002634  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000692  00000000  00000000  0000274c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000169  00000000  00000000  00002dde  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000080  00000000  00000000  00002f47  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 a0 00 	jmp	0x140	; 0x140 <__vector_1>
   8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
   c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  10:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  14:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  18:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  1c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  20:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  24:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  28:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  2c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  30:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  34:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  38:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  3c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  40:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  44:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  48:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  4c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  50:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  54:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  58:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  5c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  60:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  64:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  68:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  6c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  70:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  74:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  78:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  7c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  80:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  84:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  88:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  8c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  90:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  94:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  98:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  9c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  a0:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  a4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  a8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  ac:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  b0:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  b4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  b8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  bc:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  c0:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  c4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  c8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  cc:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  d0:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  d4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  d8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  dc:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  e0:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_clear_bss>:
  f4:	22 e0       	ldi	r18, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	01 c0       	rjmp	.+2      	; 0xfe <.do_clear_bss_start>

000000fc <.do_clear_bss_loop>:
  fc:	1d 92       	st	X+, r1

000000fe <.do_clear_bss_start>:
  fe:	a8 30       	cpi	r26, 0x08	; 8
 100:	b2 07       	cpc	r27, r18
 102:	e1 f7       	brne	.-8      	; 0xfc <.do_clear_bss_loop>
 104:	0e 94 17 01 	call	0x22e	; 0x22e <main>
 108:	0c 94 61 01 	jmp	0x2c2	; 0x2c2 <_exit>

0000010c <__bad_interrupt>:
 10c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000110 <rgb_port_config>:

void filter_clear(void) //select no filter
{
  //Filter Select - no filter
  PORTA |= (1 << S2); //set S2 High
  PORTA &= ~(1 << S3); //set S3 Low
 110:	81 b1       	in	r24, 0x01	; 1
 112:	80 6e       	ori	r24, 0xE0	; 224
 114:	81 b9       	out	0x01, r24	; 1
 116:	82 b1       	in	r24, 0x02	; 2
 118:	80 6e       	ori	r24, 0xE0	; 224
 11a:	82 b9       	out	0x02, r24	; 2
 11c:	08 95       	ret

0000011e <color_sensor_pin_config>:
 11e:	81 b1       	in	r24, 0x01	; 1
 120:	8f 60       	ori	r24, 0x0F	; 15
 122:	81 b9       	out	0x01, r24	; 1
 124:	50 98       	cbi	0x0a, 0	; 10
 126:	08 95       	ret

00000128 <color_sensor_pin_interrupt_init>:
 128:	f8 94       	cli
 12a:	e9 e6       	ldi	r30, 0x69	; 105
 12c:	f0 e0       	ldi	r31, 0x00	; 0
 12e:	80 81       	ld	r24, Z
 130:	82 60       	ori	r24, 0x02	; 2
 132:	80 83       	st	Z, r24
 134:	80 81       	ld	r24, Z
 136:	8e 7f       	andi	r24, 0xFE	; 254
 138:	80 83       	st	Z, r24
 13a:	e8 9a       	sbi	0x1d, 0	; 29
 13c:	78 94       	sei
 13e:	08 95       	ret

00000140 <__vector_1>:
 140:	1f 92       	push	r1
 142:	0f 92       	push	r0
 144:	0f b6       	in	r0, 0x3f	; 63
 146:	0f 92       	push	r0
 148:	11 24       	eor	r1, r1
 14a:	8f 93       	push	r24
 14c:	9f 93       	push	r25
 14e:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <pulse>
 152:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <pulse+0x1>
 156:	01 96       	adiw	r24, 0x01	; 1
 158:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <pulse+0x1>
 15c:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <pulse>
 160:	9f 91       	pop	r25
 162:	8f 91       	pop	r24
 164:	0f 90       	pop	r0
 166:	0f be       	out	0x3f, r0	; 63
 168:	0f 90       	pop	r0
 16a:	1f 90       	pop	r1
 16c:	18 95       	reti

0000016e <init_devices>:
 16e:	f8 94       	cli
 170:	0e 94 94 00 	call	0x128	; 0x128 <color_sensor_pin_interrupt_init>
 174:	78 94       	sei
 176:	08 95       	ret

00000178 <filter_red>:
 178:	12 98       	cbi	0x02, 2	; 2
 17a:	13 98       	cbi	0x02, 3	; 2
 17c:	08 95       	ret

0000017e <filter_green>:
 17e:	12 9a       	sbi	0x02, 2	; 2
 180:	13 9a       	sbi	0x02, 3	; 2
 182:	08 95       	ret

00000184 <filter_blue>:
 184:	12 98       	cbi	0x02, 2	; 2
 186:	13 9a       	sbi	0x02, 3	; 2
 188:	08 95       	ret

0000018a <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()   //This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
  //Output Scaling 20% from datasheet

  PORTA |= (1 << S0); //set S0 high
 18a:	10 9a       	sbi	0x02, 0	; 2
  PORTA |= (1 << S1); //set S1 high
 18c:	11 9a       	sbi	0x02, 1	; 2
 18e:	08 95       	ret

00000190 <red_read>:
}

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
  //Red
  filter_red();//select red filter
 190:	0e 94 bc 00 	call	0x178	; 0x178 <filter_red>
  pulse = 0;//reset the count to 0
 194:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <pulse+0x1>
 198:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <pulse>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 19c:	2f ef       	ldi	r18, 0xFF	; 255
 19e:	81 ee       	ldi	r24, 0xE1	; 225
 1a0:	94 e0       	ldi	r25, 0x04	; 4
 1a2:	21 50       	subi	r18, 0x01	; 1
 1a4:	80 40       	sbci	r24, 0x00	; 0
 1a6:	90 40       	sbci	r25, 0x00	; 0
 1a8:	e1 f7       	brne	.-8      	; 0x1a2 <red_read+0x12>
 1aa:	00 c0       	rjmp	.+0      	; 0x1ac <red_read+0x1c>
 1ac:	00 00       	nop
  _delay_ms(100);//capture the pulses for 100 ms or 0.1 second
  red = pulse;//store the count in variable called red
 1ae:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <pulse>
 1b2:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <pulse+0x1>
 1b6:	90 93 05 02 	sts	0x0205, r25	; 0x800205 <red+0x1>
 1ba:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <red>
 1be:	08 95       	ret

000001c0 <green_read>:
}

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
  //Green
  filter_green();//select green filter
 1c0:	0e 94 bf 00 	call	0x17e	; 0x17e <filter_green>
  pulse = 0;//reset the count to 0
 1c4:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <pulse+0x1>
 1c8:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <pulse>
 1cc:	2f ef       	ldi	r18, 0xFF	; 255
 1ce:	81 ee       	ldi	r24, 0xE1	; 225
 1d0:	94 e0       	ldi	r25, 0x04	; 4
 1d2:	21 50       	subi	r18, 0x01	; 1
 1d4:	80 40       	sbci	r24, 0x00	; 0
 1d6:	90 40       	sbci	r25, 0x00	; 0
 1d8:	e1 f7       	brne	.-8      	; 0x1d2 <green_read+0x12>
 1da:	00 c0       	rjmp	.+0      	; 0x1dc <green_read+0x1c>
 1dc:	00 00       	nop
  _delay_ms(100);//capture the pulses for 100 ms or 0.1 second
  green = pulse;//store the count in variable called green
 1de:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <pulse>
 1e2:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <pulse+0x1>
 1e6:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <green+0x1>
 1ea:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <green>
 1ee:	08 95       	ret

000001f0 <blue_read>:
}

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
  //Blue
  filter_blue(); //select blue filter
 1f0:	0e 94 c2 00 	call	0x184	; 0x184 <filter_blue>
  pulse = 0; //reset the count to 0
 1f4:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <pulse+0x1>
 1f8:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <pulse>
 1fc:	2f ef       	ldi	r18, 0xFF	; 255
 1fe:	81 ee       	ldi	r24, 0xE1	; 225
 200:	94 e0       	ldi	r25, 0x04	; 4
 202:	21 50       	subi	r18, 0x01	; 1
 204:	80 40       	sbci	r24, 0x00	; 0
 206:	90 40       	sbci	r25, 0x00	; 0
 208:	e1 f7       	brne	.-8      	; 0x202 <blue_read+0x12>
 20a:	00 c0       	rjmp	.+0      	; 0x20c <blue_read+0x1c>
 20c:	00 00       	nop
  _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
  blue = pulse;  //store the count in variable called blue
 20e:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <pulse>
 212:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <pulse+0x1>
 216:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <_edata+0x1>
 21a:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <_edata>
 21e:	08 95       	ret

00000220 <pulseCount>:
*Example call: pulseCount();
*
*/
void pulseCount(void)
{
	red_read();
 220:	0e 94 c8 00 	call	0x190	; 0x190 <red_read>
	blue_read();
 224:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <blue_read>
	green_read();
 228:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <green_read>
 22c:	08 95       	ret

0000022e <main>:



int main(void)
{
  rgb_port_config();
 22e:	0e 94 88 00 	call	0x110	; 0x110 <rgb_port_config>
  color_sensor_pin_config();
 232:	0e 94 8f 00 	call	0x11e	; 0x11e <color_sensor_pin_config>
  init_devices();
 236:	0e 94 b7 00 	call	0x16e	; 0x16e <init_devices>
  color_sensor_scaling();
 23a:	0e 94 c5 00 	call	0x18a	; 0x18a <color_sensor_scaling>
  while(1)
  {
    //Write your code here
	pulseCount();
 23e:	0e 94 10 01 	call	0x220	; 0x220 <pulseCount>
      uint16_t max = (red > blue) ? ((red > green) ? red : green) : ((green < blue) ? blue : green);	//Cool way of finding the max value, I like this one!
 242:	20 91 04 02 	lds	r18, 0x0204	; 0x800204 <red>
 246:	30 91 05 02 	lds	r19, 0x0205	; 0x800205 <red+0x1>
 24a:	40 91 00 02 	lds	r20, 0x0200	; 0x800200 <_edata>
 24e:	50 91 01 02 	lds	r21, 0x0201	; 0x800201 <_edata+0x1>
 252:	42 17       	cp	r20, r18
 254:	53 07       	cpc	r21, r19
 256:	48 f4       	brcc	.+18     	; 0x26a <main+0x3c>
 258:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <green>
 25c:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <green+0x1>
 260:	82 17       	cp	r24, r18
 262:	93 07       	cpc	r25, r19
 264:	50 f4       	brcc	.+20     	; 0x27a <main+0x4c>
 266:	c9 01       	movw	r24, r18
 268:	08 c0       	rjmp	.+16     	; 0x27a <main+0x4c>
 26a:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <green>
 26e:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <green+0x1>
 272:	84 17       	cp	r24, r20
 274:	95 07       	cpc	r25, r21
 276:	08 f4       	brcc	.+2      	; 0x27a <main+0x4c>
 278:	ca 01       	movw	r24, r20
      //uint16_t max = max(red, max(blue, green));														//Slightly cool way of finding max value from a 2 argument function
	  if(max < 1000)
 27a:	88 3e       	cpi	r24, 0xE8	; 232
 27c:	63 e0       	ldi	r22, 0x03	; 3
 27e:	96 07       	cpc	r25, r22
 280:	20 f4       	brcc	.+8      	; 0x28a <main+0x5c>
	  {
		  PORTA |= (1<<RED)|(1<<GREEN)|(1<<BLUE);
 282:	82 b1       	in	r24, 0x02	; 2
 284:	80 6e       	ori	r24, 0xE0	; 224
 286:	82 b9       	out	0x02, r24	; 2
 288:	da cf       	rjmp	.-76     	; 0x23e <main+0x10>
	  }
      else if (max == red)
 28a:	82 17       	cp	r24, r18
 28c:	93 07       	cpc	r25, r19
 28e:	29 f4       	brne	.+10     	; 0x29a <main+0x6c>
      {
        PORTA |= ((1 << BLUE) | (1 << GREEN));
 290:	82 b1       	in	r24, 0x02	; 2
 292:	80 66       	ori	r24, 0x60	; 96
 294:	82 b9       	out	0x02, r24	; 2
        PORTA &= ~(1<<RED);
 296:	17 98       	cbi	0x02, 7	; 2
 298:	d2 cf       	rjmp	.-92     	; 0x23e <main+0x10>
      }
      else if (max == green)
 29a:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <green>
 29e:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <green+0x1>
 2a2:	82 17       	cp	r24, r18
 2a4:	93 07       	cpc	r25, r19
 2a6:	29 f4       	brne	.+10     	; 0x2b2 <main+0x84>
      {
        PORTA |= ((1 << BLUE) | (1 << RED));
 2a8:	82 b1       	in	r24, 0x02	; 2
 2aa:	80 6a       	ori	r24, 0xA0	; 160
 2ac:	82 b9       	out	0x02, r24	; 2
        PORTA &= ~(1<<GREEN);
 2ae:	16 98       	cbi	0x02, 6	; 2
 2b0:	c6 cf       	rjmp	.-116    	; 0x23e <main+0x10>
      }
      else if (max == blue)
 2b2:	84 17       	cp	r24, r20
 2b4:	95 07       	cpc	r25, r21
 2b6:	19 f6       	brne	.-122    	; 0x23e <main+0x10>
      {
        PORTA |= ((1 << RED) | (1 << GREEN));
 2b8:	82 b1       	in	r24, 0x02	; 2
 2ba:	80 6c       	ori	r24, 0xC0	; 192
 2bc:	82 b9       	out	0x02, r24	; 2
        PORTA &= ~(1<<BLUE);
 2be:	15 98       	cbi	0x02, 5	; 2
 2c0:	be cf       	rjmp	.-132    	; 0x23e <main+0x10>

000002c2 <_exit>:
 2c2:	f8 94       	cli

000002c4 <__stop_program>:
 2c4:	ff cf       	rjmp	.-2      	; 0x2c4 <__stop_program>
